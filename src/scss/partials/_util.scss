@use 'config' as *;
@use 'sass:map';
@use 'sass:color';

@forward 'config' show $remValue;

/// Generate a light, dark and opac version for every color
/// next to the native value itself
/// @param {Number} $delta [5%] Amount to lighten/darken colors, null for none
/// @param {Number} $opac [0.5] Opacity of opac values, null for none
@function buildColorMap($delta: 5%, $opac: 0.5) {
    $colors: ();

    @each $name, $color in map-merge($mainPalette, $genericPalette) {
        $colors: map-merge($colors, (
            // Base colors
            $name: $color,

            // Light and dark versions
            #{$name}-light: if($delta, color.adjust($color, $lightness: $delta), null),
            #{$name}-dark: if($delta, color.adjust($color, $lightness: -$delta), null),

            // Transparent versions
            #{$name}-opac: if($opac, color.adjust($color, $alpha: -$opac), null),
            #{$name}-light-opac: if($delta and $opac, color.adjust($color, $lightness: $delta, $alpha: -$opac), null),
            #{$name}-dark-opac: if($delta and $opac, color.adjust($color, $lightness: -$delta, $alpha: -$opac), null),
        ));
    }

    @return $colors;
}

/// Translate all known SCSS colors (@see {function} buildColorMap)
/// to CSS variables
/// @output Native CSS color variables
@mixin applyColors {
    @each $name, $color in buildColorMap() {
        // Skip null values
        @if $color {
            --#{$name}: #{$color};
        }
    }
}

/// Apply styles only for a certain breakpoint
/// @param {String} $breakpoint Name of known breakpoint, @see {variable} $breakpoints
/// @param {String} $feature-type Type of query-feature, either min or max
/// @output Constructed media query with provided content
@mixin bp-style($breakpoint, $feature-type) {
    @if $feature-type != min and $feature-type != max {
        @error "Feature type #{$feature-type} is not known!";
    } 

    // Create media query based on width from map
    @if map-has-key($breakpoints, $breakpoint) {
        @media (#{$feature-type}-width: map-get($breakpoints, $breakpoint)) {
            @content;
        }
    }
    
    // Breakpoint not known within map
    @else {
        @error "Breakpoint #{$breakpoint} is not specified!";
    }
}

/// Convert pixels to rems
/// @param {Number} $pixels Pixel value
/// @return Resulting value in REMs
@function rem($pixels) {
    @return #{$pixels / $remValue}rem;
}

/// Inline keyframe animation from content
/// @param {Number} $duration Duration of animation
/// @param {boolean} $repeating [false] Whether to infinitely repeat
/// @output Keyframes declaration with unique ID and it's assignment
@mixin keyframe-animation($duration, $repeating: false) {
    // Generate unique name
    $name: kfa-#{unique-id()};

    // Create keyframes from mixin content
    @keyframes #{$name} { @content; }

    // Apply animation
    animation: $name $duration ease;
    @if $repeating {
        animation-direction: alternate;
        animation-iteration-count: infinite;
    }
}