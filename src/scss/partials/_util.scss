@use 'config' as *;
@use 'boilerplate' as *;

@use 'sass:map';
@use 'sass:color';

@forward 'config';

/// Generate a light, dark and opac version for every color
/// next to the native value itself
/// @param {Number} $delta [5%] Amount to lighten/darken colors, null for none
/// @param {Number} $opac [0.5] Opacity of opac values, null for none
@function buildColorMap($delta: 15%, $opac: 0.5) {
    $colors: ();

    @each $name, $color in map-merge($main-palette, $generic-palette) {
        $colors: map-merge($colors, (
            // Base colors
            $name: $color,

            // Light and dark versions
            #{$name}-light: if($delta, color.adjust($color, $lightness: $delta), null),
            #{$name}-dark: if($delta, color.adjust($color, $lightness: -$delta), null),

            // Transparent versions
            #{$name}-opac: if($opac, color.adjust($color, $alpha: -$opac), null),
            #{$name}-light-opac: if($delta and $opac, color.adjust($color, $lightness: $delta, $alpha: -$opac), null),
            #{$name}-dark-opac: if($delta and $opac, color.adjust($color, $lightness: -$delta, $alpha: -$opac), null),
        ));
    }

    @return $colors;
}

/// Apply styles only for a certain breakpoint
/// @param {String} $breakpoint Name of known breakpoint, @see {variable} $breakpoints
/// @param {String} $scope Scope of query, can be range | less | more | min | max
/// @output Constructed media query with provided content
@mixin bp-style($breakpoint, $scope: range) {
    // Create media query based on width from map
    @if map-has-key($breakpoints, $breakpoint) {
        $bounds: map-get($breakpoints, $breakpoint);
        $bounds-min: nth($bounds, 1);
        $bounds-max: nth($bounds, 2);

        // Max bound check
        @if ($scope == more or $scope == max) and $bounds-max == -1 {
            @error 'Cannot use max of #{$breakpoint}, (max = -1)!';
        }

        // Min bound check
        @if ($scope == less or $scope == min) and $bounds-min == -1 {
            @error 'Cannot use min of #{$breakpoint}, (min = -1)!';
        }

        // Apply min-width if not -1
        $min-instr: if(
            $bounds-min != -1 and $scope != max,
            ' and (min-width: #{$bounds-min})',
            ''
        );

        // Apply max-width if not -1
        $max-instr: if(
            $bounds-max != -1 and $scope != min,
            ' and (max-width: #{$bounds-max})',
            ''
        );

        // More: min-width: <max-bound>, no max-width
        @if $scope == more {
            $min-instr: ' and (min-width: #{$bounds-max})';
            $max-instr: '';
        }

        // Less: max-width: <min-bound>, no min-width
        @if $scope == less {
            $min-instr: '';
            $max-instr: ' and (max-width: #{$bounds-min})';
        }

        // Build query from template
        @debug '(#{$breakpoint}, #{$scope}): #{'only screen' + $min-instr + $max-instr}';
        @media #{'only screen' + $min-instr + $max-instr} {
            @content;
        }
    }
    
    // Breakpoint not known within map
    @else {
        @error 'Breakpoint #{$breakpoint} is not specified!';
    }
}

/// Convert pixels to rems
/// @param {Number} $pixels Pixel value
/// @return Resulting value in REMs
@function rem($pixels) {
    @return #{$pixels / $rem-value}rem;
}

/// Inline keyframe animation from content
/// @param {Number} $duration Duration of animation
/// @param {boolean} $repeating [false] Whether to infinitely repeat
/// @output Keyframes declaration with unique ID and it's assignment
@mixin keyframe-animation($duration, $repeating: false, $delay: 0) {
    // Generate unique name
    $name: kfa-#{unique-id()};

    // Create keyframes from mixin content
    @keyframes #{$name} { @content; }

    // Apply animation
    animation: $name $duration ease forwards;
    animation-delay: $delay;
    @if $repeating {
        animation-direction: alternate;
        animation-iteration-count: infinite;
    }
}

:root {
    // Apply color vars
    @each $name, $color in buildColorMap() {
        // Skip null values (when dark/light and or opac are disabled)
        @if $color {
            --#{$name}: #{$color};
        }
    }

    // Render initial var values directly into root
    @each $name, $value in map-get($var-states, _fallback) {
        --#{$name}: #{$value};
    }

    // Render all bp-dependent vars
    @each $breakpoint, $size in $breakpoints {
        @include bp-style($breakpoint) {
            @each $name, $value in map-get($var-states, $breakpoint) {
                --#{$name}: #{$value};
            }
        }
    }

    // Apply REM
    font-size: var(--fs-base);
}